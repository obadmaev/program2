Клиент с сервером генерируют пару ключей. 
Клиент посылает серверу свой ключ(открытый), сервер же посылает свой.
Сообщение клиента шифруется закрытым ключом клиента и открытым сервера.
Сервер получает сообщение, расшифровыывает закрытым ключом и открытым ключом клиента.
Обратное сообщение отправляется аналогичным образом.
Используется симметричное шифрование.

Демонстрация работы программы:

файл client.py:
![image](https://user-images.githubusercontent.com/80482468/146277737-2eae7a6e-8cd1-4cdd-b5c3-41f9bfb75be2.png)

файл server.py:
![image](https://user-images.githubusercontent.com/80482468/146277775-a89708a2-ccbb-4c73-9ad9-4f1dac91a6b7.png)

1. Модифицируйте код клиента и сервера так, чтобы приватный и публичный ключ хранились в текстовых файлах на диске и, таким образом, переиспользовались между запусками.

файлы для хранения ключей, ключи одинаковы, между запусками не изменяются
![image](https://user-images.githubusercontent.com/80482468/146277968-5190e8ec-a008-4316-a138-85643f38ec26.png)

2. Проведите рефакторинг кода клиента и сервера так, чтобы все, относящееся к генерации ключей, установлению режима шифрования, шифрованию исходящих и дешифрованию входящих сообщений было отделено от основного алгоритма обмена сообщениями.

Создал отдельные функции calculation_part_key, calculation_full_key, encoding, decoding, send(можно увидеть в коде)

![image](https://user-images.githubusercontent.com/80482468/146279636-2b723df9-badc-46a4-8783-f32c91ba5045.png)

файл client.py аналогично


3. Реализуйте на сервере проверку входящих сертификатов. На сервере должен храниться список разрешенных ключей. Когда клиент посылает на сервер свой публичный ключ, сервер ищет его среди разрешенных и, если такого не находит, разрывает соединение. Проверьте правильность работы не нескольких разных клиентах.

![image](https://user-images.githubusercontent.com/80482468/146280099-6ce02f51-6904-4755-8d0e-43abb58c59d8.png)
4. Модифицируйте код клиента и сервера таким образом, чтобы установление режима шифрования происходило при подключении на один порт, а основное общение - на другом порту. Номер порта можно передавать как первое зашифрованное сообщение.

![image](https://user-images.githubusercontent.com/80482468/146281948-65825cc8-440d-4a81-bf13-d96993a393d8.png)
 затем происходит переключение на новый случайный порт
 ![image](https://user-images.githubusercontent.com/80482468/146282400-bcd3a2e0-e0b5-474a-8835-d844d2a2c163.png)


